/*
  main.scss imports other SCSS files based on the 7-1 principle. main.scss acts as
  the 1 which only contains imports while the 7 refers to the seven directories
  that get imported. The directories are:
    1. abstracts  - holds Sass code that does not produce any css output such as
                    functions, mixins and variables etc.
    2. base       - holds Sass code that underpins the entire website and its pages.
                    It literally holds the base Sass code, so the body element, the
                    html element and any univeral Sass code.
    3. components - holds Sass code for components, i.e independent reusable Sass
                    bits of code that can be used anywhere. Each component has it's
                    own file in this directory.
    4. layouts    - holds Sass code related to the layouts of the web pages.
    5. pages      - holds Sass code specific to a particular web page in a website.
                    Each page in the site can have it's own file to contain Sass
                    specific to it.
    6. themes     - holds Sass code related to themes. I.e. a website could have
                    support for multiple themes. A dark theme, light theme etc.
    7. vendors    - holds Sass code from third party vendors such as Bootstrap etc.
 */
/*
  This clearfix hack works by appending a pseudo element after the element
  to be 'fixed' to clear the floats.
 */
/*
  _variables.scss holds the Sass variables of a project. It belongs to the 'abstract'
  directory which contains Sass code that is not output to a CSS file.
 */
/*
  _base.scss holds the low level basic Sass code such as resets as well as head
  and body related Sass. It belongs to the 'base' directory as it is Sass code
  related to the base of the project.
*/
/*
 '*' is the universal selector for css
 By default a browser will provide some margin and paddings in elements so we're removing them.
 */
*, *::after, *::before {
  /* include the after/before virtual elements in the global reset of margin/padding etc.*/
  margin: 0;
  padding: 0;
  box-sizing: inherit;
  /*box sizing is not inherited by default. Rather than specify it in the all selector, it is
                           practice to force inheritance of the property. Now every element will inherit the box-sizing
                           of its parent element */ }

html {
  /*font-size: 10px;*/
  /*global font-size set so that all other measurements can use rem. This means all rem measurements
                       will be relative to this measurement. Making this 10px makes calculations easier as we know 1rem
                       is 10px, i.e. 1rem * 10px = 10px. This means to convert pixel measurements to rem measurements,
                       simply divide by the pixel value by 10*/
  font-size: 62.5%;
  /* It is not good practice to specify the global font-size in pixels as it means the user can no
                       longer change the font-size via the browser. So to get around this, the global font-size is
                       set as a percentage. Default browser settings are 16px for font-size, so in order to maintain
                       1rem = 10px, we do: 10 / 16 * 100 to give us the percentage.
                     */ }

body {
  /* 'var' defines css styling for elements
  /*
    This property determines if borders and padding should count towards the width/height of an element
    border-box means the width and height include the content, padding and border.
  */
  box-sizing: border-box; }

/*
  _animation.scss holds all the animation related Sass code. It belongs to the
  'base' directory.
 */
/* Animations */
@keyframes moveInLeft {
  0% {
    /* Can specify any percentage you want. 0% is the start state, 100% is the final state*/
    opacity: 0;
    /* the opacity is 0 at the start */
    transform: translateX(-10rem);
    /* the start position is a 100px to the left */ }
  80% {
    transform: translateX(1rem);
    /* at 80% of the animation duration, the position should be 20px to the right */ }
  100% {
    opacity: 1;
    /* the opacity is 100 at the end */
    transform: translateX(0);
    /* the end position is back to the starting position */ } }

@keyframes moveInRight {
  0% {
    /* Can specify any percentage you want. 0% is the start state, 100% is the final state*/
    opacity: 0;
    /* the opacity is 0 at the start */
    transform: translateX(10rem);
    /* the start position is a 100px to the left */ }
  80% {
    transform: translateX(-1rem);
    /* at 80% of the animation duration, the position should be 20px to the right */ }
  100% {
    opacity: 1;
    /* the opacity is 100 at the end */
    transform: translateX(0);
    /* the end position is back to the starting position */ } }

@keyframes moveInBottom {
  0% {
    /* Can specify any percentage you want. 0% is the start state, 100% is the final state*/
    opacity: 0;
    /* the opacity is 0 at the start */
    transform: translateY(3rem);
    /* the start position is a 100px to the left */ }
  100% {
    opacity: 1;
    /* the opacity is 100 at the end */
    transform: translateY(0);
    /* the end position is back to the starting position */ } }

/*
  _typography.scss holds Sass code related to typograpghy. It belongs to the 'base'
  directory. Everything that is typography related should belong here.
 */
body {
  /*
    All font settings go in the body css. All elements in the body will inherit these settings
 */
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* The thickness of the font */
  /*font-size: 16px; replaced by global font-size in html elements css*/
  line-height: 1.7;
  /* 1.7 times bigger than the default */
  color: #777;
  padding: 3rem;
  /*applies padding in all sides of the body element. Child elements do not inherit padding settings */ }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  margin-bottom: 6rem;
  /*
    Property determines if whatever is behind the element is hidden during animation/translations
    Also, used as a hack to correct a slight jolt movement when animating an element. No one knows why the jolt occurs.
  */
  backface-visibility: hidden; }
  .heading-primary--main {
    display: block;
    /* block elements occupy the entire width if a width is not specified and then place a line break at the end of the element*/
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    /*animations*/
    animation-name: moveInLeft;
    /* specify the animation you defined using @keyframes*/
    animation-duration: 3s;
    animation-timing-function: ease-out;
    /* specifies the timings of the animation. such as faster in the beginning and slower in the end*/
    /*animation-delay: 3s;  <-waits 3s before running this animation */
    /*animation-iteration-count: 3; <- the number of times the animation runs*/ }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    /*animations*/
    animation-name: moveInRight;
    /* specify the animation you defined using @keyframes*/
    animation-duration: 3s;
    animation-timing-function: ease-out;
    /* specifies the timings of the animation. such as faster in the beginning and slower in the end*/ }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  /*
    Create a linear gradient on the box surrounding the text. Remember every element
    is wrapped in a box.
  */
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  display: inline-block;
  -webkit-background-clip: text;
  color: transparent;
  letter-spacing: 2px;
  transition: all .2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

/*
  _utilities.scss holds utility Sass code to perform certain functionality. It
  belongs to the 'base' directory. Utility classes are very simple classes
  that are to be reused.

  Typically using the !important property is discouraged but for utility sass
  code, it is fine because they should take precedence when used over inherited
  properties.
*/
.u-center-text {
  text-align: center !important; }

.u-margin-bottom-big {
  margin-bottom: 8rem !important; }

.u-margin-bottom-medium {
  margin-bottom: 4rem !important; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem !important; }

.u-margin-top-big {
  margin-top: 8rem !important; }

.u-margin-top-huge {
  margin-top: 10rem !important; }

/*
  _button.scss is the Sass code responsible for the button component. It is a self
  contained reusable component. It therefore belongs to the 'components' directory.
  Note each component has it's own .scss file. In this case, the button component
  has this _button.scss file.
 */
.btn {
  /*
  A pseudo class of an element represents a potential element state. An example is 'hover'.
  A pseudo class is appended to the class, separated by a colon as defined below.
  Below the 'link' state refers to an unclicked link, and a 'visited' state is when the link has been clicked.
  In our case, the state should be the same for both, hence the comma separation and singular block
*/
  /*
    Pseudo-class 'hover' applied when you have a mouseover.
  */
  /*
    Pseudo-class 'active' applied when the element is clicked

    The 'focus' pseudo class was added for the <button> element
    in the booking form. Essentially to remove the default
    focus outline (blue rectangle) and replaced with the active
    effect.
   */
  /*
    'after' pseudo-element adds a virtual element after the actual element is selected. This virtual element can also be styled
     The virtual element is treated as a child of the element itself, therefore using percentages as sizing values (see height/width settings below)
     the virtual element is sized exactly as the element itself.
  */ }
  .btn, .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    /* Specify two values means the first padding is applied to top and bottom, the second is applied to left and right */
    border-radius: 10rem;
    /* Add curved sides on the left/right of the button/anchor*/
    position: relative;
    font-size: 1.6rem;
    /*Override global font-size for button/anchor*/
    /*
      Short hand form for transition property, where first value specifies that 'all' properties can be animated, the second value specifies the animation duration
      the transition property must be set on the initial state of the element.
    */
    transition: all .2s;
    display: inline-block;
    /* inline-blocks allow other elements to sit to their left and right, respect top and bottom margins and padding and respect height and width */
    /*
      Aside: display: inline; inline elements respect left, right and margins but NOT top and bottom. They cannot have a width and height set.
      They allow other elements to sit to their left and right.
     */
    /*
      Change for the <button> element.
     */
    border: none;
    cursor: pointer; }
  .btn:hover {
    transform: translateY(-0.3rem);
    /*move the element up from bottom -> top */
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
    /*specifies the shadow, where the first value is x axis, second is y axis. The third value is the blur of the shadow. Finally, you can specify the color*/ }
    .btn:hover::after {
      /*an after virtual element only when the mouse is hovering over the element */
      transform: scaleX(1.4) scaleY(1.6);
      /* doubles the size of the element */
      opacity: 0;
      /*Set visibility to 0, in an animation this looks like a fade*/ }
  .btn:active, .btn:focus {
    outline: none;
    transform: translateY(-0.1rem);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }
  .btn--white {
    /*white button specific settings*/
    background-color: #fff;
    color: #777; }
    .btn--white::after {
      background-color: #fff; }
  .btn--green {
    /*white button specific settings*/
    background-color: #55c57a;
    color: #fff; }
    .btn--green::after {
      background-color: #55c57a; }
  .btn--animated {
    animation-name: moveInBottom;
    animation-duration: .5s;
    animation-timing-function: ease-out;
    animation-delay: .75s;
    animation-fill-mode: backwards;
    /* applies the styles of the element at 0% before the animation starts */ }
  .btn::after {
    /*
      Here we're creating a virtual element that looks exactly like the existing button. This will be the start and end state of the virtual element.
      The inbetween states will be the infinity effect.
     */
    /* content and display are mandatory properties of an 'after' pseudo-class*/
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    /*specifies the position of an element if its on top of another. -1 puts it on the bottom. */
    transition: all .4s;
    /*enable animation on all properties of this after element which will enable the hover effect on
                           on the after element defined below */ }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  transition: all .2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0); }

/*
  _composition.scss is the Sass code responsible for the photo composition you see in
  the 'About' section. It is a self contained reusable component. It therefore belongs
  to the 'components' directory.
 */
.composition {
  position: relative;
  /*
    When hovering over a photo, we want to shrink the other photos in the composition.
    In order to do this, when we hover over a composition, we select the sub-elements that
    ARE NOT hovered.
    The below selector translates to:
      composition:hover composition__photo:not(:hover)

    I.e When we hover over a composition ('composition:hover') we select the sub elements
    ('composition__photo') that are not hovered (':not(:hover)')
   */ }
  .composition__photo {
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    /*
      By making this absolute, its position is relative to the first parent element
      that has its position set. In this case we want the photo composition to be relative
      to the element with class 'composition' so it has its position set to relative. See
      line 9;
      This means the position of the element with this class ('__photo') is at (0,0) of the
      parent element with class 'composition'. Therefore you can provide adjustments by way of
      'left','top','right','bottom' properties to move the element.
     */
    position: absolute;
    /*
      Give every element with class '__photo' a default z-index of 10. This is then overridden
      when hovering, resulting in the hovered element placed on top. See line 52.
     */
    z-index: 10;
    transition: all 0.2s;
    outline-offset: 2rem; }
    .composition__photo--p1 {
      left: 0;
      top: -2rem; }
    .composition__photo--p2 {
      right: 0;
      top: 2rem; }
    .composition__photo--p3 {
      left: 20%;
      top: 10rem; }
    .composition__photo:hover {
      transform: scale(1.05) translateY(-5rem);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      z-index: 20;
      /*
        Create a box around the hovered photo with a gap. By using 'outline' instead of
        border, we can create the gap by specifying an 'outline-offset' property in
        the un-hovered state. See line 32.
       */
      outline: 1.5rem solid #55c57a; }
  .composition:hover .composition__photo:not(:hover) {
    transform: scale(0.95); }

/*
  _feature-box.scss is the Sass code responsible for the boxes displayed in the 'Feature'
  section. It is a self contained reusable component. It therefore belongs to the 'components'
  directory.
 */
.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition: transform .3s; }
  .feature-box__icon {
    font-size: 6rem;
    margin-bottom: .5rem;
    /*
      Create a linear gradient on the box surrounding the icon. Remember every element
      is wrapped in a box.
    */
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    display: inline-block;
    -webkit-background-clip: text;
    color: transparent;
    letter-spacing: 2px;
    transition: all .2s; }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

/*
  _cards.scss is the Sass code responsible for the rotating cards displayed in the
  'Tours' section. It is a self contained reusable component. It therefore belongs to
  the 'components' directory.
 */
.card {
  /*
    The perspective property is an effect to make the element appear to move closer to
    you, in this case during rotation. The lower the perspective the more dramatic the
    effect.
   */
  perspective: 150rem;
  -moz-perspective: 150rem;
  position: relative;
  /*
    Because absolute positioning was used in the child elements, this took
    the child elements out of the natural flow. The parent, in this case the
    element with class 'card' collapses to having a 0 height. This is similar
    to what happens when using floats.
    However, whereas with floats, the clearfix hack can be used, with absolute
    positioning, this cannot be done. So we simply specify the height to be the
    same as the child elements.
   */
  height: 52rem;
  /*
    When hovering over the card, then the card__side element should
    be transformed, in this case rotated. We don't want to transform
    on the hover alone because we may want to perform other actions
    based on other classes, not just card__side. In our case, we want
    to do different things based on the front and back.
   */
  /*
   The back of the card is already rotated at 180degrees by default.
   Therefore when we hover over it, we want it to rotate back to 0deg.
   This ensures that the front and back are opposite at any given time.
   I.e. start: back  = 180deg rotated.
               front = 0deg rotated.
        hover: back  = 0deg rotated.
               front = 180deg rotated.
   */
  /*
    The sass code below is for the Front side styling
   */
  /*
    Back side styling
   */ }
  .card__side {
    font-size: 2rem;
    height: 52rem;
    transition: all .8s ease;
    position: absolute;
    top: 0;
    left: 0;
    /*
      By specifying positioning properties, the width is adjusted to the size
      of the content. However, we want the width of the card to take up the
      entire container.
     */
    width: 100%;
    /*
      Hides the back of an element. I.e. during rotation or some transformation.
      Without it, you would see the element as though from the back, i.e, the
      content of the element would be flipped as though in a mirror. You can
      test this by simply viewing text within a div and rotating the div.
     */
    backface-visibility: hidden;
    border-radius: 3px;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
    /*
      Set overflow to hidden so that when the image is placed
      on the card (see line 118), it does not hide the rounded edges.
     */
    overflow: hidden;
    /*
      The back of the card is already set to 180deg. Therefore when you
      hover over the card, only the front of the card needs to rotate
      180deg.
     */ }
    .card__side--front {
      background-color: #fff; }
    .card__side--back {
      transform: rotateY(180deg); }
      .card__side--back--1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
      .card__side--back--2 {
        background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
      .card__side--back--3 {
        background-image: linear-gradient(to right bottom, #2998ff, #5643fa); }
  .card:hover .card__side--front {
    transform: rotateY(-180deg); }
  .card:hover .card__side--back {
    transform: rotateY(0); }
  .card__picture {
    background-size: cover;
    height: 23rem;
    background-blend-mode: screen;
    -webkit-clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    border-top-left-radius: 3px;
    border-top-right-radius: 3px; }
    .card__picture--1 {
      /*
        Assumes this sass becomes the main.css file, therefore go up one
        directory for img folder.
        Also blending the image with a linear gradient. This can only be
        done with a background-image. Hence why we're not just using the
        <img> element in the html.
       */
      background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url(../img/nat-5.jpg); }
    .card__picture--2 {
      background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url(../img/nat-6.jpg); }
    .card__picture--3 {
      background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url(../img/nat-7.jpg); }
  .card__heading {
    font-size: 2.8rem;
    font-weight: 300;
    text-transform: uppercase;
    text-align: right;
    color: #fff;
    position: absolute;
    top: 12rem;
    right: 2rem;
    width: 75%; }
  .card__heading-span {
    padding: 1rem 1.5rem;
    /*
      splits an inline block spread across multiple lines into separate
      blocks, where line has it's own block. The 'clone' setting applies
      the styles of the selector to each separate block rather than to
      the original single inline block.
     */
    -webkit-box-decoration-break: clone; }
    .card__heading-span--1 {
      background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85)); }
    .card__heading-span--2 {
      background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85)); }
    .card__heading-span--3 {
      background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85)); }
  .card__details {
    padding: 3rem; }
    .card__details ul {
      list-style: none;
      width: 80%;
      margin: 0 auto; }
      .card__details ul li {
        text-align: center;
        font-size: 1.5rem;
        padding: 1rem; }
        .card__details ul li:not(:last-child) {
          border-bottom: 1px solid #eee; }
  .card__cta {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    text-align: center; }
  .card__price-box {
    text-align: center;
    margin-bottom: 8rem;
    color: #fff; }
  .card__price-only {
    font-size: 1.4rem;
    text-transform: uppercase; }
  .card__price-value {
    font-size: 6rem;
    font-weight: 100; }

/*
  _story.scss is the Sass code responsible for the user stories (trapezoid boxes with
  circular photos) displayed in the 'Stories' section. It is a self contained reusable
  component. It therefore belongs to the 'components' directory.
 */
.story {
  width: 75%;
  margin: 0 auto;
  box-shadow: 0 3rem 6rem rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.6);
  border-radius: 3px;
  padding: 6rem;
  padding-left: 9rem;
  font-size: 1.6rem;
  transform: skewX(-12deg); }
  .story__shape {
    width: 15rem;
    height: 15rem;
    float: left;
    /*
      Using the shape-outside property to wrap the other elements around it. Similar
      to the polygon function used when clipping, we're using the circle function
      to define the circle. The first arg is the radius. If you specify 50%, it
      will be half of the containing element, in this case that will be 15/2 = 7.5rem.
      The diameter will therefore be 2*radius which is the size of the enclosing
      element, i.e. 15rem;
      The second arg is the co-ordinate of the centre of the circle. Again, by making
      it 50% 50%, it exactly in the middle.
      The shape-outside property only works if it is FLOATED and has DEFINED DIMENSIONS,
      i.e. the width and height are specified.
     */
    -webkit-shape-outside: circle(50% at 50% 50%);
    shape-outside: circle(50% at 50% 50%);
    -webkit-clip-path: circle(50% at 50% 50%);
    clip-path: circle(50% at 50% 50%);
    /*
      This transform takes precedence over the transform specified in the direct
      child selector on line 21 because it is more specific (narrower scope).
      Therefore, the child selector does not work and is commented out.
      The skew needs to be manually added here.
    */
    transform: translateX(-3rem) skewX(12deg);
    position: relative; }
  .story__img {
    height: 100%;
    transform: translateX(-4rem) scale(1.4);
    backface-visibility: hidden;
    transition: all .5s; }
  .story__text {
    /*
      skew needs to be manually added here because the direct child selector
      will not work because the transform trying to be applied is overriden by
      the one in the &__shape selector. Therefore the children need to have the skew
      set manually.
     */
    transform: skewX(12deg); }
  .story__caption {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 20%);
    opacity: 0;
    transition: all .5s;
    backface-visibility: hidden;
    color: #fff;
    text-transform: uppercase;
    font-size: 1.7rem;
    text-align: center; }
  .story:hover .story__caption {
    opacity: 1;
    transform: translate(-50%, -50%); }
  .story:hover .story__img {
    transform: translateX(-4rem) scale(1);
    /*
      filter properties to blur etc. There are several other filters that can
      be applied. A brightness value below 100% is darker. Above is brighter.
     */
    filter: blur(3px) brightness(80%); }

/*
  _form.scss holds the Sass code related to the booking form. It belongs to the
   'component' directory as it is a reusable and independent.
*/
.form {
  /*
    Styling on the label element when the input placeholder is
    shown. The label is an adjacent sibling element of the
    input element. By 'adjacent' we mean an element that
    appears immediately after.
    There are 2 sibling selectors.
      ~ == general sibling selector. I.e. selects any sibling
           of the current element.
      + == adjacent sibling selector

     IMPORTANT: You can only select siblings that appear after
     the current element. From the current element it is NOT
     possible to select previous sibling elements in the HTML.
   */
  /*
    The custom radio button
   */
  /*
    Use the checked pseudo class available to all radio buttons to determine
    whether the custom button should have the inner circles displayed, i.e.
    selected.
    The selector below first selects the radio button once in a checked
    state. It then selects the sibling element, i.e. the radio-label and
    finally it selects the child, i.e. the span elements 'after' state
    aka our custom radio button 'after' state defined on line 104.
   */ }
  .form__group {
    margin-bottom: 2rem; }
  .form__input {
    font-size: 1.5rem;
    /*
      Input elements don't inherit font properties so
      we set it to inherit automatically.
     */
    font-family: inherit;
    color: inherit;
    padding: 1.5rem 2rem;
    border-radius: 2px;
    background-color: rgba(255, 255, 255, 0.5);
    border: none;
    border-bottom: 3px solid transparent;
    width: 90%;
    display: block;
    transition: all .3s;
    /*
    A pseudo element (represented by 2 colons). They represent
    things that are actually on the webpage.
   */ }
    .form__input::-webkit-input-placeholder {
      color: #999; }
    .form__input:focus {
      outline: none;
      box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.1);
      border-bottom: 3px solid #55c57a; }
      .form__input:focus:invalid {
        border-bottom: 3px solid #ff7730; }
  .form__label {
    font-size: 1.2rem;
    font-weight: 700;
    margin-left: 2rem;
    margin-top: .7rem;
    display: block;
    transition: all .3s; }
  .form__input:placeholder-shown + .form__label {
    opacity: 0;
    visibility: hidden;
    transform: translateY(-4rem); }
  .form__radio-group {
    width: 49%;
    display: inline-block; }
  .form__radio-label {
    font-size: 1.6rem;
    cursor: pointer;
    position: relative;
    padding-left: 4.5rem; }
  .form__radio-button {
    height: 3rem;
    width: 3rem;
    border: 5px solid #55c57a;
    border-radius: 50%;
    display: inline-block;
    position: absolute;
    left: 0;
    top: -.4rem; }
    .form__radio-button::after {
      content: "";
      display: block;
      height: 1.3rem;
      width: 1.3rem;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #55c57a;
      opacity: 0; }
  .form__radio-input:checked ~ .form__radio-label .form__radio-button:after {
    opacity: 1; }
  .form__radio-input {
    display: none; }

/*
  _bg-video.scss is the Sass code responsible for the adding the background image to
  the stories section. It is a self contained reusable component. It therefore
  belongs to the 'components' directory.
 */
.bg-video {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  z-index: -1;
  opacity: .15;
  overflow: hidden; }
  .bg-video__content {
    height: 100%;
    width: 100%;
    /*
      The settings above will not work on their own. This is
      because simply adjusting the height and width will force
      the browser to resize but only whilst maintaining the
      aspect ratio of the video.
      The property below fixes this. It is similar to the
      background cover setting. It will fill the parent element
      while maintaining the aspect ratio. Anything that goes
      outside of the parent element is clipped.
     */
    object-fit: cover; }

/*
  _header.scss holds the header related Sass code. It could be considered a component
  as it is reusable independent Sass code. However, it belongs to the 'layouts'
  directory because a header is related to the layout. This is of course subjective.
 */
.header {
  /* '.var' defines css styling for classes */
  height: 95vh;
  /* The height is 95% of the viewport height (vh). The viewport is what is visible in the browser. This setting will therefore leave 5% at the bottom of the viewport*/
  /*
     Specifying an imgs in your project source. Below two imgs are used, one linear-gradient and one img file (hero.jpg). Depending on what you want on top,
     the order of the imgs is important. The top most must always be first. Below, the hero.jpg is at the bottom, the gradient applied on top.
     The 'to right bottom' property on the gradient specifies the direction of the gradient applied from the top-left corner to the bottom right.
     Note the colors are provided as rgba instead of the #hex values. This is to provide the final value which determines the transparency (0.8 in this case)
  */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  background-size: cover;
  /* 'cover' fits the entire viewport with the element this class is applied to */
  background-position: top;
  /* property sets the starting position of a background image, top-left being the default. If only one value is given, the second is 'center'*/
  /*
     defines a polygon in terms of a series of (x y) co-ordinates  to show in view for this element. Important, this polygon is what you will see, not what will be clipped.
     You can use any measurement to define the x and y co-ordinates including percent or pixel as below.
     The -webkit-clip-path is to support other browsers.
  */
  -webkit-clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /*
   The element is positioned relative to its normal position. I.e. regardless of it's position, relative left:20px
   would add 20px to the elements left
  */
  position: relative;
  /*
    Nesting selectors can be done for both elements and classes. Nesting selectors for elements is
    the typical case. Whereby you can have something like the following:
      ul {
        li {
          a {}
        }
      }

      however you can do the same with classes that share a prefix using the '&' notation. Below
      we've removed the 'header__...' classes and nested them in the '.header' selector.
   */ }
  .header__logo-box {
    position: absolute;
    /* The element is positioned relative to its first positioned ancestor element */
    top: 4rem;
    /*40px from the top, relative to the parent element*/
    left: 4rem;
    /*40px from the left, relative to the parent element*/ }
  .header__logo {
    height: 3.5rem;
    /*width will be auto calculated by the browser, so only height is needed. */ }
  .header__text-box {
    position: absolute;
    top: 40%;
    /*Positions the the top-left corner of the element to 40% from the top.*/
    left: 50%;
    /*Positions the top-left corner of the element 50% from the left */
    /*
      The top, left properties have moved the element such that it starts from 50% of the parent so it needs to be
      adjusted by translation. The below moves the element 50% of its width, 50% of its height in the left and top directions.
      Percentages refer to the height and width of the element itself, i.e. it's own bounding box.
     */
    transform: translate(-50%, -50%);
    text-align: center;
    /* this moves the anchor 'discover our tours' to the center because the anchor is an inline-block so is treated as text */ }

.row {
  /*
    Max-width specifies the maximum width an element can be provided the current
    viewport width is large enough. If the current viewport width is smaller than
    the max-width, then the element takes up the entire width available.
   */
  max-width: 114rem;
  /*
    Trick to center a block element inside of another block element. Here we're
    saying the top and bottom margins are 0 and the left and right margins are
    'auto'. This works because the browser is left to render the left and right
    margins. As they are both 'auto' the browser sets both left and right margins
    to the same value. This forces the element to the middle.
   */
  margin: 0 auto;
  /*
    Using the 'not' function to say apply to all except the last element. The 'not' function
    takes a pseudo class as an argument.
   */
  /*
    This is an 'attribute' selector. E.g if you had html such as <img src="a">
    Then you could select all elements that had a 'src' attribute with the following:
      [src="a"] {...}
    The '^' symbol says give me all elements with attributes that START WITH whatever
    is specified. E.g. if you had html such as <img src="a_monkey_sat">. Then you
    could select all elements that had a 'src' attribute that started with "a_monkey"
    with the following:
      [src=^="a_monkey"] {...}

    = == EQUAL
    ^ == STARTS WITH
    * == CONTAINS
    $ == ENDS WITH

    Here, we're selecting all elements that have a class starting with 'col-'. I.e.
    all the columns.
   */
  /*
    The below provides the following layout col widths.
    [--------------------100%-----------------------]
    [--col 1--][gutter][--col 1--][gutter][--col 1--]
    [--col 1--][gutter][----------col 2-------------]
   */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    /*
      content property needs to be provided else the pseudo element 'after' will not
      appear on the page. It's set to empty because we don't actually want to see
      the pseudo element on the page.
     */
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    /*
      All columns are floated to the left to create a sequence. However, this means
      that the parent 'row' element has a height of 0px (because all the child elements
      are floated). Therefore the 'clearfix' hack needs to be applied in order to
      view the vertical margin of the row defined above ($gutter-vertical).
      See line 27 for the clearfix hack being included. It is defined in the _mixins
      .scss file.
     */
    float: left;
    /*
      Here we're saying that each column in the row except the last should have margin
      attached to the right(defined as the $gutter-horizontal in our case).
     */ }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    /*
      The calc function allows you to perform calculations on mixed units. E.g.
      calculations with pixels and rem etc. These calculations take place while
      the page is rendered using the formatting model as that is when the measurements
      are truly known (rems, percentages etc.) for a layout.

      If using variables ($gutter-horizontal) in your calc function, then you need
      to wrap it in 'myVariable' as below.

      The calculation is saying take 100% width of the parent element and subtract
      the space. This gives you the length of 2 columns separated by the middle margin
      or gutter. Then divide by 2 to get each column width.
        [------------100%------------]
        [--col 1--][gutter][--col 2--]
     */
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    /*
      The below provides the following layout col widths.
      [---------------------100%----------------------]
      [--col 1--][gutter][--col 2--][gutter][--col 3--]
     */
    width: calc((100% - 2 * 6rem) / 3); }
  .row .col-1-of-4 {
    width: calc((100% - 3 * 6rem) / 4); }
  .row .col-2-of-3 {
    width: calc(2 * ((100% - 2 * 6rem) / 3) + 6rem); }
  .row .col-2-of-4 {
    width: calc(2 * ((100% - 3 * 6rem) / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc(3 * ((100% - 3 * 6rem) / 4) + 2 * 6rem); }

.navigation {
  /*
    The original checkbox that the custom button is linked to via a label.
   */
  /*
    The toggle button to open the navigation screen.
   */
  /*
    The green circle that sits behind the button so that when the button is
    clicked, it gives the expanding effect into the navigation screen using
    a radial gradient/circular gradient.
   */
  /*
    This is the navigation screen. It is a container for navigation list
    of items.
    Cover the entire viewport (hence 100vh) with the gradient background.
   */
  /*
    Container for the navigation items. It is centered in the middle.
   */
  /*
      Checkbox hack. Select the background when the original checkbox is
      checked.
     */
  /*
    The navigation button is made of 3 lines. The middle line is the span
    element in the html. The first line is the 'before' pseudo element and
    the last line is the 'after' pseudo element.
    When the button is clicked, the span element or middle line disappears
    and the first and last lines rotate to create a cross.
   */
  /*
    rotate the first and last lines and move them so the lines cross
    can also use the transform-origin property to specify which point the
    rotation happens around.
   */ }
  .navigation__checkbox {
    display: none; }
  .navigation__button {
    background-color: #fff;
    height: 7rem;
    width: 7rem;
    position: fixed;
    top: 6rem;
    right: 6rem;
    border-radius: 50%;
    z-index: 2000;
    box-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.1);
    text-align: center;
    cursor: pointer; }
  .navigation__background {
    height: 6rem;
    width: 6rem;
    border-radius: 50%;
    z-index: 1000;
    /*
      Fixed essentially means it doesn't move as you scroll
      the page. It's also like absolute in that it takes the
      element out of the flow and can be positioned using
      the top,left,right and bottom properties.
     */
    position: fixed;
    top: 6.5rem;
    right: 6.5rem;
    /*
      Radial gradients starts in the middle and expands outwards in a circle.
     */
    background-image: radial-gradient(#7ed56f, #28b485);
    /*
      Easing function to specify how much change occurs over time. The easing
      function is the cubic-bezier function (can be googled for various numbers
      for the bezier curve you want)
     */
    transition: transform 0.8s cubic-bezier(0.86, 0, 0.07, 1); }
  .navigation__nav {
    height: 100vh;
    position: fixed;
    top: 0;
    right: 0;
    z-index: 1500;
    opacity: 0;
    width: 0;
    transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
  .navigation__list {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    list-style: none;
    text-align: center;
    width: 100%; }
  .navigation__item {
    margin: 1rem; }
  .navigation__link {
    /*
      Need to review why this works
     */ }
    .navigation__link:link, .navigation__link:visited {
      display: inline-block;
      font-size: 3rem;
      font-weight: 300;
      padding: 1rem 2rem;
      color: #fff;
      text-decoration: none;
      text-transform: uppercase;
      /*
      Use solid color gradient to give white angled box animation effect.
      First rotate by 120deg to give slope/angled box. Then provide gradient
      colors at various widths. At 0% width, the color is TRANSPARENT.
      It is also TRANSPARENT at 50%. So it is a solid gradient from 0-50%.
      Then 50% onwards, it is WHITE therefore another solid gradient from
      50-100.
      If the background size initial state was 100%, then the TRANSPARENT
      and WHITE sides would occupy 50% of container (in this case, the list
      item) as per the linear gradient setting. If the background size is
      set to 200%, the WHITE is completely gone. In fact it has just
      expanded outside of the container and is no longer visible.
      This is the crux of the animation. I.e. the background position can
      be adjusted when hovering to bring the WHITE side back into view
      (back into the container). See hover pseudo class below.
       */
      background-image: linear-gradient(120deg, transparent 0%, transparent 50%, #fff 50%);
      background-size: 220%;
      transition: all .4s; }
      .navigation__link:link span, .navigation__link:visited span {
        margin-right: 1.5rem;
        display: inline-block; }
    .navigation__link:hover, .navigation__link:active {
      background-position: 100%;
      color: #55c57a;
      transform: translateX(1rem); }
  .navigation__checkbox:checked ~ .navigation__background {
    transform: scale(60); }
  .navigation__checkbox:checked ~ .navigation__nav {
    opacity: 1;
    width: 100%; }
  .navigation__icon {
    position: relative;
    margin-top: 3.5rem; }
    .navigation__icon, .navigation__icon::before, .navigation__icon::after {
      width: 3rem;
      height: 2px;
      background-color: #333;
      display: inline-block; }
    .navigation__icon::before, .navigation__icon::after {
      content: "";
      position: absolute;
      left: 0;
      transition: all .2s; }
    .navigation__icon::before {
      top: -.8rem; }
    .navigation__icon::after {
      top: .8rem; }
  .navigation__button:hover .navigation__icon::before {
    top: -1rem; }
  .navigation__button:hover .navigation__icon::after {
    top: 1rem; }
  .navigation__checkbox:checked + .navigation__button .navigation__icon {
    /*
      We want to keep the position of this span/middle line so that the
      before and after lines which are positioned in relation to the
      middle line, do not change.
      We therefore only change the color of the line.
     */
    background-color: transparent; }
  .navigation__checkbox:checked + .navigation__button .navigation__icon::before {
    transform: rotate(135deg);
    top: 0; }
  .navigation__checkbox:checked + .navigation__button .navigation__icon::after {
    transform: rotate(-135deg);
    top: 0; }

/*
  _footer.scss holds the footer related Sass code. It could be considered a component
  as it is reusable independent Sass code. However, it belongs to the 'layouts'
  directory because a footer is related to the layout. This is of course subjective.
 */
.footer {
  background-color: #333;
  padding: 10rem 0;
  font-size: 1.4rem; }
  .footer__logo-box {
    /*
      <img> is an inline element and so behaves like text. We can
      therefore center it as we do with text.
     */
    text-align: center;
    margin-bottom: 8rem; }
  .footer__logo {
    width: 15rem;
    height: auto; }
  .footer__navigation {
    border-top: 1px solid #777;
    padding-top: 2rem;
    display: inline-block; }
  .footer__list {
    list-style: none; }
  .footer__item {
    display: inline-block; }
    .footer__item:not(:last-child) {
      margin-right: 1.5rem; }
  .footer__link:link, .footer__link:visited {
    background-color: #333;
    color: #f7f7f7;
    text-decoration: none;
    text-transform: uppercase;
    display: inline-block;
    transition: all .2s; }
  .footer__link:hover, .footer__link:active {
    color: #55c57a;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4); }
  .footer__copyright {
    color: #f7f7f7;
    border-top: 1px solid #777;
    padding-top: 2rem;
    display: inline-block;
    width: 80%;
    float: right; }

/*
  _home.scss holds the Sass code related to the home page or landing page of the
  website. It belongs to the 'pages' directory as it is Sass code related to a
  particular page.
*/
.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  /*
    The background is set to grey which means that the triangle/wedge
    clipped from the bottom of the title view is mismatched because
    it will be white. We know from the _header.scss file that the height
    of the header is 95vh or 95% of the viewport height. We also know
    that the polygon clipped to create the wedge is 75vh or 75% of the
    viewport. Therefore the wedge height is 20vh and we move this section
    up using negative top margin by that amount in order to fill the color
    with light-grey as per this section.
   */
  margin-top: -20vh; }

.section-features {
  padding: 20rem 0;
  /*
    This is similar sass code used for the background image in the _header.scss
    file
   */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/nat-4.jpg");
  background-size: cover;
  margin-top: -10rem;
  transform: skewY(-7deg);
  /*
    This is the 'direct child selector' and is used to select the direct children
    of the element with this class (i.e. section-features).
    The * in the selector below is the universal selector, the '>' denote the direct child.
    Therefore this evaluates to: 'select all (*) direct children (>)'.

    I.e.:
      '& > *' == 'Select all direct children'
      '& *'   == 'Select all children'
   */ }
  .section-features > * {
    transform: skewY(7deg); }

.section-tours {
  background-color: #f7f7f7;
  padding: 25rem 0 15rem 0;
  margin-top: -10rem; }

.section-stories {
  padding: 15rem 0;
  position: relative; }

.section-book {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }

.book {
  /*
    Specifying a gradient that sits on top of the image. The first arg of the
    linear-gradient is the direction. This can be provided in words, i.e.
    "to right bottom" or it can be specified in degrees. By default the gradient is
    bottom to top but by rotation this goes from left to right.
    The angle of 105 degrees ends up producing the diagonal line.
    The linear gradient allows you to specify multiple colors and at what percentage
    of the image that gradient should extend to. So below, the gradient start at 0%
    width with a white color. Then at 50% width,the color is also white. So there is a
    white-to-white gradient from 0% to 50%. Then from 50% onwards, there is no gradient,
    i.e, complete transparency to give the end result.
   */
  background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.9) 50%, rgba(255, 255, 255, 0) 50%), url(../img/nat-10.jpg);
  background-size: cover;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.2);
  height: 50rem; }
  .book__form {
    width: 50%;
    padding: 6rem; }
